# ─────────────────────────────────────────────────────────────────────────────
# Publish to Chrome Web Store
#
# Triggers:
#   • Push a semver tag  (v1.2.3)  → build, upload, and publish to Trusted Testers
#   • Manual dispatch              → choose upload-only (draft) or full publish
#                                    and choose audience (trustedTesters | default)
#
# Required GitHub repository secrets:
#   CHROME_CLIENT_ID      – OAuth 2.0 Client ID (Desktop App)
#   CHROME_CLIENT_SECRET  – OAuth 2.0 Client Secret
#   CHROME_REFRESH_TOKEN  – Refresh token obtained via the one-time OAuth flow
#                           (see README.md → Publishing to the Chrome Web Store)
# ─────────────────────────────────────────────────────────────────────────────

name: Publish to Chrome Web Store

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      upload_only:
        description: 'Upload only — skip publish step (creates a draft)'
        required: true
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'
      publish_target:
        description: 'Publish audience'
        required: true
        default: 'trustedTesters'
        type: choice
        options:
          - trustedTesters
          - default

# Extension ID (not a secret — it is part of the public store URL)
env:
  EXTENSION_ID: mcpbdhphpebimnmeinngdbabbgcfmccj

jobs:
  publish:
    name: Build & Publish Extension
    runs-on: ubuntu-latest

    steps:
      # ── 1. Source ──────────────────────────────────────────────────────────
      - name: Checkout repository
        uses: actions/checkout@v4

      # ── 2. Node.js ─────────────────────────────────────────────────────────
      - name: Set up Node.js 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      # ── 3. Dependencies ────────────────────────────────────────────────────
      - name: Install dependencies
        # npm install instead of npm ci: sharp's lock file entries are
        # platform-specific (win32 vs linux), so npm ci fails on Linux when
        # the lock file was generated on Windows.
        run: npm install

      # ── 4. Icons ───────────────────────────────────────────────────────────
      - name: Generate PNG icons from SVG
        run: npm run icons

      # ── 5. Build ───────────────────────────────────────────────────────────
      - name: Build extension
        run: npm run build

      # ── 6. Package ─────────────────────────────────────────────────────────
      - name: Create extension zip
        run: |
          cd dist
          zip -r ../social-media-saver.zip .
          cd ..
          echo "Zip size: $(du -sh social-media-saver.zip | cut -f1)"

      # ── 7. OAuth access token ──────────────────────────────────────────────
      - name: Get OAuth access token
        id: token
        env:
          CHROME_CLIENT_ID: ${{ secrets.CHROME_CLIENT_ID }}
          CHROME_CLIENT_SECRET: ${{ secrets.CHROME_CLIENT_SECRET }}
          CHROME_REFRESH_TOKEN: ${{ secrets.CHROME_REFRESH_TOKEN }}
        run: |
          RESPONSE=$(curl -s -X POST https://oauth2.googleapis.com/token \
            --data-urlencode "client_id=$CHROME_CLIENT_ID" \
            --data-urlencode "client_secret=$CHROME_CLIENT_SECRET" \
            --data-urlencode "refresh_token=$CHROME_REFRESH_TOKEN" \
            --data-urlencode "grant_type=refresh_token")

          ACCESS_TOKEN=$(echo "$RESPONSE" | jq -r '.access_token')

          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then
            echo "ERROR: Could not obtain access token."
            echo "$RESPONSE" | jq .
            exit 1
          fi

          # Mask the token so it never appears in logs
          echo "::add-mask::$ACCESS_TOKEN"
          echo "access_token=$ACCESS_TOKEN" >> "$GITHUB_OUTPUT"

      # ── 8. Upload ──────────────────────────────────────────────────────────
      - name: Upload to Chrome Web Store
        id: upload
        env:
          ACCESS_TOKEN: ${{ steps.token.outputs.access_token }}
        run: |
          echo "Uploading social-media-saver.zip …"
          RESPONSE=$(curl -s -X PUT \
            "https://www.googleapis.com/upload/chromewebstore/v1.1/items/$EXTENSION_ID" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "x-goog-api-version: 2" \
            -T social-media-saver.zip)

          echo "Upload response:"
          echo "$RESPONSE" | jq .

          UPLOAD_STATE=$(echo "$RESPONSE" | jq -r '.uploadState')
          if [ "$UPLOAD_STATE" != "SUCCESS" ]; then
            echo "ERROR: Upload failed — uploadState=$UPLOAD_STATE"
            exit 1
          fi

          echo "Upload succeeded."

      # ── 9. Publish ─────────────────────────────────────────────────────────
      #  Runs when:
      #    • triggered by a git tag push  (always publishes to trustedTesters)
      #    • triggered manually AND upload_only == 'false'
      - name: Publish to Chrome Web Store
        if: >
          github.event_name == 'push' ||
          (github.event_name == 'workflow_dispatch' &&
           github.event.inputs.upload_only == 'false')
        env:
          ACCESS_TOKEN: ${{ steps.token.outputs.access_token }}
        run: |
          TARGET="${{ github.event.inputs.publish_target || 'trustedTesters' }}"
          echo "Publishing to audience: $TARGET"

          RESPONSE=$(curl -s -X POST \
            "https://www.googleapis.com/chromewebstore/v1.1/items/$EXTENSION_ID/publish?publishTarget=$TARGET" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "x-goog-api-version: 2" \
            -H "Content-Length: 0")

          echo "Publish response:"
          echo "$RESPONSE" | jq .

          STATUS=$(echo "$RESPONSE" | jq -r '.status[0]')
          case "$STATUS" in
            OK | ITEM_PENDING_REVIEW)
              echo "Published successfully (status: $STATUS)"
              ;;
            *)
              echo "ERROR: Publish failed — status=$STATUS"
              exit 1
              ;;
          esac
